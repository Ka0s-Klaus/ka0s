import os
import re

DOCS_DIR = 'core/docs'
README_PATH = os.path.join(DOCS_DIR, 'README.md')
MARKER_START = '<!-- MODULES_START -->'
MARKER_END = '<!-- MODULES_END -->'

def find_main_doc(folder_path, folder_name):
    # Priority list for main files
    priorities = [
        f"{folder_name}.md",
        "README.md",
        "index.md",
        "kaos-klaus.md", # Exception for release
        "docker.md"      # Exception for docker
    ]
    
    # Check specific priorities first
    for p in priorities:
        if os.path.exists(os.path.join(folder_path, p)):
            return p
            
    # Fallback: first markdown file that isn't legacy or partial
    files = [f for f in os.listdir(folder_path) if f.endswith('.md')]
    if not files:
        return None
        
    # Heuristic: try to find the shortest name or one that resembles the folder
    # Sort by length to prefer shorter names (e.g. ka0s.md vs ka0s_metodologia.md)
    files.sort(key=len)
    return files[0]

def get_title(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip().startswith('# '):
                    return line.strip().replace('# ', '').strip()
    except Exception:
        pass
    return None

def generate_index():
    modules = []
    
    # List all subdirectories in core/docs
    try:
        entries = sorted(os.listdir(DOCS_DIR))
    except FileNotFoundError:
        print(f"Error: Directory {DOCS_DIR} not found.")
        return

    for entry in entries:
        folder_path = os.path.join(DOCS_DIR, entry)
        
        # Skip non-directories or hidden folders
        if not os.path.isdir(folder_path) or entry.startswith('.'):
            continue
            
        # Skip the 'ka0s' folder itself if it's considered meta-docs, 
        # OR include it if it's a module. 
        # Based on existing README, 'ka0s.yml' points to ka0s_core/ka0s_core.md
        # Let's process everything and let the logic decide.
        
        main_file = find_main_doc(folder_path, entry)
        if main_file:
            full_path = os.path.join(folder_path, main_file)
            title = get_title(full_path)
            
            # Formatting the link name
            # If title exists, use it? Or use folder name formatted?
            # Existing README uses filename mostly: "ka0s.yml", "inspector.yml"
            # But the user asked for "Better and more complete".
            # Let's use the Title from the MD file if available, falling back to Folder Name.
            
            display_name = title if title else entry.replace('ka0s_', '').replace('_', ' ').title()
            
            # Special formatting to match style if desired (e.g. "Module Name")
            # Or keep it simple: "- [Title](./path)"
            
            rel_path = f"./{entry}/{main_file}"
            modules.append(f"- [{display_name}]({rel_path})")

    return modules

def update_readme(modules_list):
    with open(README_PATH, 'r', encoding='utf-8') as f:
        content = f.read()
    
    new_section = f"{MARKER_START}\n"
    new_section += "<!-- This section is automatically generated by .github/scripts/update-docs-index.py -->\n\n"
    new_section += "\n".join(modules_list)
    new_section += f"\n\n{MARKER_END}"
    
    # Regex to replace content between markers
    pattern = re.compile(f"{re.escape(MARKER_START)}.*?{re.escape(MARKER_END)}", re.DOTALL)
    
    if pattern.search(content):
        new_content = pattern.sub(new_section, content)
        with open(README_PATH, 'w', encoding='utf-8') as f:
            f.write(new_content)
        print("README.md updated successfully.")
    else:
        print("Markers not found in README.md")

if __name__ == "__main__":
    print("Generating Documentation Index...")
    modules = generate_index()
    if modules:
        update_readme(modules)
        print("Done.")
    else:
        print("No modules found.")
