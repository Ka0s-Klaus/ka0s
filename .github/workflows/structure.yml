name: Ka0s Create structure for dashboard
on:
  push:
    branches:
      - 'H*'
      - 'F*'
      - 'RN*'
    paths:
      - 'core/config/webs/**'
      - 'core/testweb/**'
  workflow_dispatch:
env:
    KAOS_CODE: ${{ github.run_id }}
    KAOS_EVENT_NAME: ${{ github.event_name }}
    KAOS_ACTION: ${{ github.action }}
    KAOS_REF: ${{ github.ref }}
    KAOS_MODULE: "[Ka0S] Deploy Web Structure"
    KAOS_JSON_WEB: "core/config/webs/webs.json"
    KAOS_JSON_RESUME: "core/outputs/webs/" # directorio que aloja los json de resultados de la operación 
    KAOS_JSON_DATA: "core/web/data/data.json" # directorio que aloja los json de datos de la operación
    KAOS_WEB_STRUCTURE: "core/results/webs/" # directorio donde se alojan las diferentes estructura de webs
    KAOS_TEST_STRUCTURE: "core/results/test/" # directorio donde se alojará la estructura de testweb
    KAOS_ACTOR: ${{ github.actor }}
    KAOS_TEST_JSON_WEB: "core/testweb/data/webs.json" # archivo JSON para el dashboard de test
    KAOS_TEST_JSON_DATA: "core/testweb/data/data.json" # archivo JSON de datos para el dashboard de test
jobs:
  job-core:
    runs-on:
      group: ka0s
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      
      - name: Copy web folder structure
        run: |
          # Tenemos que añadir al proceso que sea capaz de leer + de un json de creación de webs
          # si web esta creada la actualiza, sino la crea desde cero

          # Read the structure.json file to get folder names
          echo "0 - Reading structure.json file..."
          STRUCTURE_FILE="${{ env.KAOS_JSON_WEB }}"
          
          # Extract title for main folder name
          TITLE=$(cat $STRUCTURE_FILE | jq -r '.title')
          echo "I - Main folder will be named: $TITLE"

          # Create main directory
          mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TITLE"
          touch ${{ env.KAOS_WEB_STRUCTURE }}$TITLE/$TITLE".html"
          mkdir -p "${{ env.KAOS_JSON_RESUME }}$TITLE"
          touch ${{ env.KAOS_JSON_RESUME }}$TITLE/readme.txt

          # Copy the directory structure (without files)
          find core/web -type d | while read dir; do
            if [ "$dir" != "core/web" ]; then
              # Remove core/web prefix from directory path
              clean_dir=${dir#core/web/}
              echo "II - Created directory: $clean_dir"
              target_dir="${{ env.KAOS_WEB_STRUCTURE }}$TITLE/$clean_dir"
              mkdir -p "$target_dir"
              touch $target_dir/$clean_dir".html"
              echo "II - Created directory: $target_dir"
            fi
          done

          # Extract section information and create subfolders
          jq -r 'to_entries | .[] | select(.key | startswith("section")) | [.key, .value.title, .value.icon, .value.data] | @tsv' $STRUCTURE_FILE | while IFS=$'\t' read -r section_key section_title section_icon section_data; do
            echo "III - Creating subfolder for section: $section_key - $section_title"
            mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/structure/$section_title"
            touch ${{ env.KAOS_WEB_STRUCTURE }}$TITLE/structure/$section_title/$section_title".html"
            
            # Guardar la ruta del archivo JSON de datos para esta sección
            if [ ! -z "$section_data" ]; then
              # Copiar el contenido del archivo JSON en lugar de solo la ruta
              if [ -f "$section_data" ]; then
                cp "$section_data" "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/structure/$section_title/$section_title.json"
                echo "    Data source: $section_data (copiado)"
              else
                # Si el archivo no existe, guardar al menos la ruta como referencia
                echo "$section_data" > "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/structure/$section_title/$section_title.json"
                echo "    Data source: $section_data (ruta guardada, archivo no encontrado)"
              fi
            fi
          done
          
          # Create a JSON file with the structure information
          echo "[" > ${{ env.KAOS_JSON_RESUME }}$TITLE/$TITLE"_resume.json"
          # Find all files and directories
          find ${{ env.KAOS_WEB_STRUCTURE }} -type f -o -type d | sort | while read path; do
            if [ "$path" != "${{ env.KAOS_WEB_STRUCTURE }}" ]; then
              # Get the type (file or directory)
              if [ -d "$path" ]; then
                TYPE="directory"
              else
                TYPE="file"
              fi
              # Get the name of the item (last part of path)
              NAME=$(basename "$path")
              # Create the JSON entry
              echo "  {\"path\": \"$path\", \"name\": \"$NAME\", \"type\": \"$TYPE\"}," >> ${{ env.KAOS_JSON_RESUME }}$TITLE/$TITLE"_resume.json"
            fi
          done
          # Remove the last comma and close the JSON array
          sed -i '$ s/,$//' ${{ env.KAOS_JSON_RESUME }}$TITLE/$TITLE"_resume.json"
          echo "]" >> ${{ env.KAOS_JSON_RESUME }}$TITLE/$TITLE"_resume.json"
          echo "IV - Web folder structure copied successfully!"
          
          # NUEVA SECCIÓN: Copiar estructura de testweb
          echo "V - Creating test structure from testweb folder..."
          # Crear directorio principal para test
          mkdir -p "${{ env.KAOS_TEST_STRUCTURE }}"
          mkdir -p "${{ env.KAOS_JSON_RESUME }}test"
          touch ${{ env.KAOS_JSON_RESUME }}test/readme.txt
          
          # Copiar la estructura de directorios de testweb (sin archivos)
          find core/testweb -type d | while read dir; do
            if [ "$dir" != "core/testweb" ]; then
              # Eliminar el prefijo core/testweb de la ruta del directorio
              clean_dir=${dir#core/testweb/}
              echo "VI - Created test directory: $clean_dir"
              target_dir="${{ env.KAOS_TEST_STRUCTURE }}$clean_dir"
              mkdir -p "$target_dir"
              touch $target_dir/$clean_dir".html"
              echo "VI - Created test directory: $target_dir"
            fi
          done
          
          # Copiar todos los archivos de testweb a la estructura de test
          find core/testweb -type f | while read file; do
            # Eliminar el prefijo core/testweb de la ruta del archivo
            clean_file=${file#core/testweb/}
            target_file="${{ env.KAOS_TEST_STRUCTURE }}$clean_file"
            # Asegurarse de que el directorio de destino existe
            mkdir -p "$(dirname "$target_file")"
            # Copiar el archivo
            cp "$file" "$target_file"
            echo "VII - Copied file: $file to $target_file"
          done
          
          # Crear un archivo JSON con la información de la estructura de test
          echo "[" > ${{ env.KAOS_JSON_RESUME }}test/test_resume.json
          # Encontrar todos los archivos y directorios
          find ${{ env.KAOS_TEST_STRUCTURE }} -type f -o -type d | sort | while read path; do
            if [ "$path" != "${{ env.KAOS_TEST_STRUCTURE }}" ]; then
              # Obtener el tipo (archivo o directorio)
              if [ -d "$path" ]; then
                TYPE="directory"
              else
                TYPE="file"
              fi
              # Obtener el nombre del elemento (última parte de la ruta)
              NAME=$(basename "$path")
              # Crear la entrada JSON
              echo "  {\"path\": \"$path\", \"name\": \"$NAME\", \"type\": \"$TYPE\"}," >> ${{ env.KAOS_JSON_RESUME }}test/test_resume.json
            fi
          done
          # Eliminar la última coma y cerrar el array JSON
          sed -i '$ s/,$//' ${{ env.KAOS_JSON_RESUME }}test/test_resume.json
          echo "]" >> ${{ env.KAOS_JSON_RESUME }}test/test_resume.json
          echo "VII - Test folder structure copied successfully!"
          
          # NUEVA SECCIÓN: Crear dashboard de test en la estructura de webs
          echo "VIII - Creating test dashboard in webs structure..."
          # Leer el archivo webs.json de testweb
          TEST_STRUCTURE_FILE="${{ env.KAOS_TEST_JSON_WEB }}"
          
          # Extraer título para el nombre de la carpeta principal
          TEST_TITLE="test"
          echo "IX - Test dashboard will be named: $TEST_TITLE"
          
          # Crear directorio principal para el dashboard de test
          mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE"
          
          # En lugar de solo crear un archivo vacío, crear un archivo HTML básico
          cat > ${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/$TEST_TITLE".html" << 'EOL'
          <!DOCTYPE html>
          <html lang="es">
          <head>
              <meta charset="UTF-8">
              <meta name="viewport" content="width=device-width, initial-scale=1.0">
              <title>Sección Ka0s</title>
              <link href="../css/output.css" rel="stylesheet">
              <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
              <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
          </head>
          <body class="bg-gray-100 min-h-screen">
              <div class="flex">
                  <!-- Incluir el navbar -->
                  <div id="navbar-container"></div>
  
                  <!-- Contenido principal -->
                  <div class="ml-[250px] w-full transition-all duration-300 p-6" id="main-content">
                      <header class="mb-8">
                          <h1 class="text-3xl font-bold text-gray-800" id="section-title">SECTION_TITLE_PLACEHOLDER</h1>
                          <p class="text-gray-600 mt-2" id="section-description">SECTION_DESCRIPTION_PLACEHOLDER</p>
                      </header>
  
                      <!-- Contenedor de métricas - se generará dinámicamente -->
                      <div id="metrics-container" class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
                          <!-- Las métricas se generarán dinámicamente según el JSON -->
                      </div>
  
                      <!-- Contenedor de plantillas - se generará dinámicamente -->
                      <div id="templates-container">
                          <!-- Las plantillas (gráficos, listas, etc.) se generarán dinámicamente según el JSON -->
                      </div>
                  </div>
              </div>
  
              <!-- Scripts -->
              <script src="../js/orchestrator.js"></script>
          </body>
          </html>
          EOL
          
          mkdir -p "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE"
          touch ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/readme.txt
          
          # Copiar la estructura de directorios de testweb a la estructura de webs
          find core/testweb -type d | while read dir; do
            if [ "$dir" != "core/testweb" ]; then
              # Eliminar el prefijo core/testweb de la ruta del directorio
              clean_dir=${dir#core/testweb/}
              echo "X - Created test web directory: $clean_dir"
              target_dir="${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/$clean_dir"
              mkdir -p "$target_dir"
              touch $target_dir/$clean_dir".html"
              echo "X - Created test web directory: $target_dir"
            fi
          done
          
          # Extraer información de secciones y crear subcarpetas
          if [ -f "$TEST_STRUCTURE_FILE" ]; then
            jq -r '.sections[] | [.title, .icon, .data] | @tsv' $TEST_STRUCTURE_FILE | while IFS=$'\t' read -r section_title section_icon section_data; do
              echo "XI - Creating subfolder for test section: $section_title"
              mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/structure/$section_title"
              touch ${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/structure/$section_title/$section_title".html"
              
              # Guardar la ruta del archivo JSON de datos para esta sección
              if [ ! -z "$section_data" ]; then
                # Si section_data es un array, procesarlo
                if [[ "$section_data" == "["* ]]; then
                  echo "$section_data" > "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/structure/$section_title/$section_title.json"
                  echo "    Data source: Array data (guardado)"
                else
                  # Copiar el contenido del archivo JSON en lugar de solo la ruta
                  if [ -f "$section_data" ]; then
                    cp "$section_data" "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/structure/$section_title/$section_title.json"
                    echo "    Data source: $section_data (copiado)"
                  else
                    # Si el archivo no existe, guardar al menos la ruta como referencia
                    echo "$section_data" > "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/structure/$section_title/$section_title.json"
                    echo "    Data source: $section_data (ruta guardada, archivo no encontrado)"
                  fi
                fi
              fi
            done
          else
            echo "Warning: Test webs.json file not found at $TEST_STRUCTURE_FILE"
          fi
          
          # Crear un archivo JSON con la información de la estructura
          echo "[" > ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/$TEST_TITLE"_resume.json"
          # Encontrar todos los archivos y directorios
          find ${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE -type f -o -type d | sort | while read path; do
            if [ "$path" != "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE" ]; then
              # Obtener el tipo (archivo o directorio)
              if [ -d "$path" ]; then
                TYPE="directory"
              else
                TYPE="file"
              fi
              # Obtener el nombre del elemento (última parte de la ruta)
              NAME=$(basename "$path")
              # Crear la entrada JSON
              echo "  {\"path\": \"$path\", \"name\": \"$NAME\", \"type\": \"$TYPE\"}," >> ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/$TEST_TITLE"_resume.json"
            fi
          done
          # Eliminar la última coma y cerrar el array JSON
          sed -i '$ s/,$//' ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/$TEST_TITLE"_resume.json"
          echo "]" >> ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/$TEST_TITLE"_resume.json"
          echo "XII - Test web folder structure created successfully!"
          
      - id: upload-files
        name: Upload Files
        run: |
          echo "Uploading files to the repository..."
          git config --global user.name "${{ secrets.KAOS_BOT_NAME }}"
          git config --global user.email "${{ secrets.KAOS_BOT_EMAIL }}"
          git pull
          # Asegurarse de que la carpeta web_structure se añade explicitamente
          git add ${{ env.KAOS_WEB_STRUCTURE }}*
          git add ${{ env.KAOS_TEST_STRUCTURE }}*
          git add ${{ env.KAOS_JSON_RESUME }}*
          # Verificar si hay cambios para hacer commit
          if git diff --staged --quiet; then
            echo "No hay cambios para hacer commit"
          else
            git commit -m "[Ka0S] Uploading resume execution files and web/test structure to the repository..."
            git push origin ${{ env.KAOS_REF }}
          fi
  job-data:
    runs-on:
      group: ka0s
    needs: [job-core]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      
      - name: Copy data files to web structure
        run: |
          echo "Reading data.json file..."
          DATA_FILE="${{ env.KAOS_JSON_DATA }}"
          echo "Data file: $DATA_FILE"
          
          # Extract title for main folder name from structure file
          STRUCTURE_FILE="${{ env.KAOS_JSON_WEB }}"
          TITLE=$(jq -r '.title' $STRUCTURE_FILE)
          if [ -z "$TITLE" ]; then
            TITLE="dashboard"
            echo "Title not found in JSON file, using default: $TITLE"
          else
            echo "Main folder is named: $TITLE"
          fi
          
          # Create data directory if it doesn't exist
          mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/data"
          
          # Copiar el archivo webs.json a la estructura
          cp $STRUCTURE_FILE "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/data/webs.json"
          echo "Copied webs.json to data directory"
          
          # Copiar todos los archivos JSON de core/web/data a la estructura
          echo "Copying all JSON files from core/web/data directory..."
          find core/web/data -name "*.json" -type f | while read -r json_file; do
            # Obtener el nombre del archivo
            JSON_FILENAME=$(basename "$json_file")
            echo "Copying JSON file: $json_file to data directory"
            cp "$json_file" "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/data/$JSON_FILENAME"
          done
          echo "All JSON files from core/web/data copied successfully!"
          
          # Read data.json and copy files
          if [ -f "$DATA_FILE" ]; then
            echo "Processing data files from data.json..."
            
            # Extract source and destination paths
            jq -c '.dataFiles[]' "$DATA_FILE" | while read -r file; do
              SOURCE=$(echo $file | jq -r '.source')
              DEST=$(echo $file | jq -r '.destination')
              echo "Source: $SOURCE"
              echo "Destination: $DEST"

              # Ensure destination directory exists
              DEST_DIR=$(dirname "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/$DEST")
              mkdir -p "$DEST_DIR"
              echo "Destination directory: $DEST_DIR"
              
              # Copy the file
              if [ -f "$SOURCE" ]; then
                echo "Copying $SOURCE to ${{ env.KAOS_WEB_STRUCTURE }}$TITLE/$DEST"
                cp "$SOURCE" "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/$DEST"
              else
                echo "Warning: Source file $SOURCE not found"
              fi
            done
            
            echo "Data files copied successfully!"
          else
            echo "Warning: data.json file not found at $DATA_FILE"
          fi
          
          # Copiar los archivos JSON de datos de sección
          echo "Copying section data files..."
          jq -r 'to_entries | .[] | select(.key | startswith("section")) | .value.data' $STRUCTURE_FILE | while read data_path; do
            if [ ! -z "$data_path" ] && [ -f "$data_path" ]; then
              # Obtener el nombre del archivo
              DATA_FILENAME=$(basename "$data_path")
              echo "Copying section data file: $data_path to data directory"
              cp "$data_path" "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/data/$DATA_FILENAME"
            fi
          done
          
          # Generate a summary of copied files
          echo "Generating data files summary..."
          echo "{" > "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          echo "  \"generated_at\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"," >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          echo "  \"title\": \"$TITLE\"," >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          echo "  \"files\": [" >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          
          # List all copied files
          find "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/data" -type f | sort | while read -r file; do
            RELATIVE_PATH="${file#${{ env.KAOS_WEB_STRUCTURE }}$TITLE/}"
            echo "    {\"path\": \"$RELATIVE_PATH\"}," >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          done
          
          # Remove the last comma and close the JSON
          sed -i '$ s/,$//' "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          echo "  ]" >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          echo "}" >> "${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          
          echo "Data files summary generated at ${{ env.KAOS_JSON_RESUME }}$TITLE/data-files-summary.json"
          
          # NUEVA SECCIÓN: Copiar archivos de datos para el dashboard de test
          echo "Reading test data.json file..."
          TEST_DATA_FILE="${{ env.KAOS_TEST_JSON_DATA }}"
          echo "Test data file: $TEST_DATA_FILE"
          
          # Establecer el título para el dashboard de test
          TEST_TITLE="test"
          echo "Test dashboard is named: $TEST_TITLE"
          
          # Crear directorio de datos si no existe
          mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/data"
          
          # Copiar el archivo webs.json de testweb a la estructura
          cp ${{ env.KAOS_TEST_JSON_WEB }} "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/data/webs.json"
          echo "Copied test webs.json to data directory"
          
          # Copiar todos los archivos JSON de core/testweb/data a la estructura
          echo "Copying all JSON files from core/testweb/data directory..."
          find core/testweb/data -name "*.json" -type f | while read -r json_file; do
            # Obtener el nombre del archivo
            JSON_FILENAME=$(basename "$json_file")
            echo "Copying JSON file: $json_file to test data directory"
            cp "$json_file" "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/data/$JSON_FILENAME"
          done
          echo "All JSON files from core/testweb/data copied successfully!"
          
          # Leer data.json de testweb y copiar archivos
          if [ -f "$TEST_DATA_FILE" ]; then
            echo "Processing data files from test data.json..."
            
            # Extraer rutas de origen y destino
            jq -c '.dataFiles[]' "$TEST_DATA_FILE" | while read -r file; do
              SOURCE=$(echo $file | jq -r '.source')
              DEST=$(echo $file | jq -r '.destination')
              echo "Source: $SOURCE"
              echo "Destination: $DEST"

              # Asegurar que el directorio de destino existe
              DEST_DIR=$(dirname "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/$DEST")
              mkdir -p "$DEST_DIR"
              echo "Destination directory: $DEST_DIR"
              
              # Copiar el archivo
              if [ -f "$SOURCE" ]; then
                echo "Copying $SOURCE to ${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/$DEST"
                cp "$SOURCE" "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/$DEST"
              else
                echo "Warning: Source file $SOURCE not found"
              fi
            done
            
            echo "Test data files copied successfully!"
          else
            echo "Warning: test data.json file not found at $TEST_DATA_FILE"
          fi
          
          # Copiar los archivos JSON de datos de sección para test
          echo "Copying test section data files..."
          if [ -f "${{ env.KAOS_TEST_JSON_WEB }}" ]; then
            jq -r '.sections[].data' ${{ env.KAOS_TEST_JSON_WEB }} | while read data_path; do
              if [ ! -z "$data_path" ]; then
                # Verificar si es un array o una cadena
                if [[ "$data_path" == "["* ]]; then
                  echo "Skipping array data: $data_path"
                elif [ -f "$data_path" ]; then
                  # Obtener el nombre del archivo
                  DATA_FILENAME=$(basename "$data_path")
                  echo "Copying test section data file: $data_path to test data directory"
                  cp "$data_path" "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/data/$DATA_FILENAME"
                fi
              fi
            done
          fi
          
          # Generar un resumen de los archivos copiados para test
          echo "Generating test data files summary..."
          echo "{" > "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          echo "  \"generated_at\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"," >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          echo "  \"title\": \"$TEST_TITLE\"," >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          echo "  \"files\": [" >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          
          # Listar todos los archivos copiados
          find "${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/data" -type f | sort | while read -r file; do
            RELATIVE_PATH="${file#${{ env.KAOS_WEB_STRUCTURE }}$TEST_TITLE/}"
            echo "    {\"path\": \"$RELATIVE_PATH\"}," >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          done
          
          # Eliminar la última coma y cerrar el JSON
          sed -i '$ s/,$//' "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          echo "  ]" >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          echo "}" >> "${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
          
          echo "Test data files summary generated at ${{ env.KAOS_JSON_RESUME }}$TEST_TITLE/data-files-summary.json"
      
      - id: copy-json   
        name: Copiar archivos JSON de config/webs a data
        run: |
          # Extraer título para el nombre de la carpeta principal desde el archivo de estructura
          STRUCTURE_FILE="${{ env.KAOS_JSON_WEB }}"
          TITLE=$(jq -r '.title' $STRUCTURE_FILE)
          if [ -z "$TITLE" ]; then
            TITLE="dashboard"
            echo "Título no encontrado en el archivo JSON, usando el valor predeterminado: $TITLE"
          else
            echo "La carpeta principal se llama: $TITLE"
          fi
          
          echo "Copiando archivos JSON de core/config/webs a data..."
          mkdir -p "core/results/webs/${TITLE}/data"
          
          # Copiar todos los archivos JSON de core/config/webs a la estructura
          find core/config/webs -name "*.json" -type f | while read -r json_file; do
            # Obtener el nombre del archivo
            JSON_FILENAME=$(basename "$json_file")
            echo "Copiando archivo JSON: $json_file a data directory"
            cp "$json_file" "core/results/webs/${TITLE}/data/$JSON_FILENAME"
          done
          echo "Todos los archivos JSON de core/config/webs copiados exitosamente!"
          
          # Copiar archivos JSON de testweb a la estructura de test
          TEST_TITLE="test"
          echo "Copiando archivos JSON de core/testweb a data de test..."
          mkdir -p "core/results/webs/${TEST_TITLE}/data"
          
          # Copiar todos los archivos JSON de core/testweb a la estructura
          find core/testweb -name "*.json" -type f | while read -r json_file; do
            # Obtener el nombre del archivo
            JSON_FILENAME=$(basename "$json_file")
            echo "Copiando archivo JSON: $json_file a test data directory"
            cp "$json_file" "core/results/webs/${TEST_TITLE}/data/$JSON_FILENAME"
          done
          echo "Todos los archivos JSON de core/testweb copiados exitosamente!"

      - id: upload-files
        name: Upload Files
        run: |
          echo "Uploading data files to the repository..."
          git config --global user.name "${{ secrets.KAOS_BOT_NAME }}"
          git config --global user.email "${{ secrets.KAOS_BOT_EMAIL }}"
          git pull
          # Add the data files and summary
          git add ${{ env.KAOS_WEB_STRUCTURE }}**/data/*
          git add ${{ env.KAOS_JSON_RESUME }}*
          # Verify if there are changes to commit
          if git diff --staged --quiet; then
            echo "No hay cambios para hacer commit"
          else
            git commit -m "[Ka0S] Uploading data files to web structure..."
            git push origin ${{ env.KAOS_REF }}
          fi
      
  job-design:
    runs-on:
      group: ka0s
    needs: [job-core, job-data]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      
      - name: Preparar directorios y copiar archivos estáticos
        run: |
          # Configuración inicial
          STRUCTURE_FILE="${{ env.KAOS_JSON_WEB }}"
          TITLE=$(cat $STRUCTURE_FILE | jq -r '.title')
          
          # Crear directorios necesarios
          mkdir -p "${{ env.KAOS_WEB_STRUCTURE }}$TITLE/js"
          mkdir -p "core/results/webs/${TITLE}/templates"
          mkdir -p "core/results/webs/${TITLE}/temp_sections"
          
          # Copiar archivos de plantillas
          find core/web/templates -type f -name "*.html" | while read -r template_file; do
            # Obtener el nombre del archivo
            TEMPLATE_FILENAME=$(basename "$template_file")
            echo "Copiar plantilla: $template_file a templates directory"
            cp "$template_file" "core/results/webs/${TITLE}/templates/$TEMPLATE_FILENAME"
          done
          echo "Todas las plantillas HTML copiadas exitosamente!"
          
          # Verificar si el archivo dashboard.html existe y no está rastreado
          if [ -f "core/results/webs/${TITLE}/dashboard.html" ] && ! git ls-files --error-unmatch "core/results/webs/${TITLE}/dashboard.html" > /dev/null 2>&1; then
            echo "El archivo dashboard.html existe pero no está rastreado. Añadiéndolo al staging..."
            git add "core/results/webs/${TITLE}/dashboard.html"
            git commit -m "[Ka0S] Añadiendo dashboard.html antes del pull"
          fi
          
          # Hacer pull con estrategia de recursión para manejar conflictos
          git pull --strategy-option=theirs
      
      - name: Generar HTML de secciones
        run: |
          STRUCTURE_FILE="core/config/webs/webs.json"
          TITLE=$(jq -r '.title' $STRUCTURE_FILE)
          echo "Generando HTML de secciones según su JSON para el título: ${TITLE}"
          
          # Procesar cada sección en el archivo webs.json
          jq -r 'to_entries | .[] | select(.key | startswith("section")) | [.key, .value.title, .value.data] | @tsv' $STRUCTURE_FILE | while IFS=$'\t' read -r section_key section_title section_data; do
            echo "Procesando sección: $section_key - $section_title - $section_data"
            
            if [ ! -z "$section_data" ] && [ -f "$section_data" ]; then
              SECTION_HTML="core/results/webs/${TITLE}/structure/${section_title}/${section_title}.html"
              
              # Extraer título de la sección desde el archivo JSON de datos
              SECTION_TITLE=$(jq -r '.title' "$section_data")
              
              # Leer la plantilla HTML
              TEMPLATE_HTML="core/web/templates/section-template.html"
              if [ -f "$TEMPLATE_HTML" ]; then
                # Copiar la plantilla al destino
                mkdir -p "$(dirname "$SECTION_HTML")"
                cp "$TEMPLATE_HTML" "$SECTION_HTML"
                
                # Reemplazar los placeholders con los valores reales
                sed -i "s/SECTION_TITLE_PLACEHOLDER/$SECTION_TITLE/g" "$SECTION_HTML"
                
                # Comprobar si hay un placeholder para lista de sección y procesarlo
                if grep -q "SECTION_LIST_PLACEHOLDER" "$SECTION_HTML"; then
                  echo "Encontrado placeholder para lista de sección, procesando..."
                  # Verificar si el JSON de la sección tiene una lista en sus templates
                  if jq -e '.templates[] | select(.type == "list")' "$section_data" > /dev/null; then
                    # Obtener el primer template de tipo list
                    LIST_TEMPLATE_JSON=$(jq -c '.templates[] | select(.type == "list")' "$section_data" | head -1)
                    LIST_TITLE=$(echo "$LIST_TEMPLATE_JSON" | jq -r '.title')
                    LIST_DATA_SOURCE=$(echo "$LIST_TEMPLATE_JSON" | jq -r '.dataSource')
                    
                    # Leer la plantilla de lista
                   
                    
                    # Crear un archivo temporal con la plantilla de lista modificada
                    TEMP_LIST=$(mktemp)
                    
                      sed "s|{{TEMPLATE_TITLE}}|$LIST_TITLE|g" | 
                      sed "s|{{DATA_SOURCE}}|$LIST_DATA_SOURCE|g" > "$TEMP_LIST"
                    
                    # Crear un archivo temporal para el resultado final
                    TEMP_RESULT=$(mktemp)
                    
                    # Usar awk para reemplazar el placeholder con el contenido del archivo temporal
                    awk -v placeholder="SECTION_LIST_PLACEHOLDER" -v replacement="$(cat $TEMP_LIST)" '{
                      gsub(placeholder, replacement)
                      print
                    }' "$SECTION_HTML" > "$TEMP_RESULT"
                    
                    # Mover el resultado al archivo final
                    mv "$TEMP_RESULT" "$SECTION_HTML"
                    
                    # Limpiar archivos temporales
                    rm -f "$TEMP_LIST"
                    
                    echo "Añadido componente de lista a la sección"
                  else
                    echo "La sección no tiene una lista definida, eliminando placeholder"
                    sed -i "s|SECTION_LIST_PLACEHOLDER||g" "$SECTION_HTML"
                  fi
                fi
                
                # Procesar templates y reemplazar el placeholder de templates
                TEMPLATES_HTML=""
                jq -c '.templates[]' "$section_data" | while read -r template; do
                  TYPE=$(echo $template | jq -r '.type')
                  TITLE=$(echo $template | jq -r '.title')
                  DATA_SOURCE=$(echo $template | jq -r '.dataSource')
                  
                  if [ "$TYPE" = "graphic" ]; then
                    # Leer la plantilla de gráfico
                   
                    # Reemplazar placeholders en la plantilla
                    GRAPHIC_TEMPLATE=$(echo "$GRAPHIC_TEMPLATE" | sed "s/GRAPHIC_TITLE_PLACEHOLDER/$TITLE/g")
                    GRAPHIC_TEMPLATE=$(echo "$GRAPHIC_TEMPLATE" | sed "s|DATA_SOURCE_PLACEHOLDER|$DATA_SOURCE|g")
                    TEMPLATES_HTML+="$GRAPHIC_TEMPLATE"
                    # Añadir referencia a Chart.js antes del script graphic.js
                    TEMPLATES_HTML+="<script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>"
                    # Modificar la forma de incluir el script para que pueda recibir el data-source
                  elif [ "$TYPE" = "list" ]; then
                    # Leer la plantilla de lista
                    
                    # Reemplazar placeholders en la plantilla
                    LIST_TEMPLATE=$(echo "$LIST_TEMPLATE" | sed "s/LIST_TITLE_PLACEHOLDER/$TITLE/g")
                    LIST_TEMPLATE=$(echo "$LIST_TEMPLATE" | sed "s|DATA_SOURCE_PLACEHOLDER|$DATA_SOURCE|g")
                    TEMPLATES_HTML+="$LIST_TEMPLATE"
                    
                  fi
                done
                
                # Reemplazar el placeholder de templates con el HTML generado
                awk -v r="$TEMPLATES_HTML" '{gsub("<!-- TEMPLATES_PLACEHOLDER -->", r)} 1' "$SECTION_HTML" > temp && mv temp "$SECTION_HTML"
                
                # Asegurarse de que la referencia a orchestrator.js sea correcta
                sed -i 's|src="../js/orchestrator.js"|src="../../js/orchestrator.js"|g' "$SECTION_HTML"
                
                echo "Generado $SECTION_HTML"
                # Almacenar cada sección en un directorio temporal para concatenarlas después
                mkdir -p "core/results/webs/${TITLE}/temp_sections"
                cp "$SECTION_HTML" "core/results/webs/${TITLE}/temp_sections/${section_title}.html"
              else
                echo "Error: No se encontro la plantilla HTML en $TEMPLATE_HTML"
              fi
            else
              echo "No se encontró el archivo de datos para la sección: $section_data"
            fi
          done
      
      - name: Crear dashboard.html
        run: |
          STRUCTURE_FILE="core/config/webs/webs.json"
          TITLE=$(jq -r '.title' $STRUCTURE_FILE)
          
          # Crear el dashboard.html con todas las secciones concatenadas y la navbar
          echo "<!DOCTYPE html>
          <html lang=\"es\">
          <head>
              <meta charset=\"UTF-8\">
              <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
              <title>Ka0s Dashboard - ${TITLE}</title>
              <link rel=\"stylesheet\" href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css\">
          </head>
          <body class=\"bg-gray-50\">
              <!-- Incluir la navbar -->
              <div id=\"navbar-container\"></div>
              
              <div id=\"main-content\" class=\"ml-[250px] transition-all duration-300\">
                  <div class=\"container mx-auto px-4 py-8\">
                      <header class=\"py-3 mb-4 border-b border-gray-200\">
                          <div class=\"flex items-center\">
                              <h1 class=\"text-2xl font-bold text-gray-800\">${TITLE}</h1>
                          </div>
                      </header>
                      <div class=\"dashboard-content\">" > "core/results/webs/${TITLE}/dashboard.html"
          
          # Concatenar todas las secciones
          if [ -d "core/results/webs/${TITLE}/temp_sections" ]; then
            for section_file in "core/results/webs/${TITLE}/temp_sections"/*.html; do
              if [ -f "$section_file" ]; then
                SECTION_NAME=$(basename "$section_file" .html)
                echo "<div class=\"section-content\" id=\"${SECTION_NAME}\">" >> "core/results/webs/${TITLE}/dashboard.html"
                
                # Extraer solo el contenido del body de cada sección
                TEMP_CONTENT=$(mktemp)
                awk '/<body/,/<\/body>/' "$section_file" > "$TEMP_CONTENT"
                
                # Filtrar el contenido para eliminar etiquetas innecesarias
                cat "$TEMP_CONTENT" | 
                  grep -v "<body" | 
                  grep -v "</body>" | 
                  
                  
                
                # Limpiar archivos temporales
                rm -f "$TEMP_CONTENT"
                
                echo "</div>" >> "core/results/webs/${TITLE}/dashboard.html"
              fi
            done
          else
            echo "No se encontró el directorio de secciones temporales"
          fi
          
          # Cerrar las etiquetas HTML
          echo "          </div>
              </div>
              </div>
          </div>
          
          <!-- Cargar la navbar desde el template -->
          <script src="js/orchestrator.js"></script>
          </body>
          </html>" >> "core/results/webs/${TITLE}/dashboard.html"
          
          echo "Dashboard HTML generado correctamente en core/results/webs/${TITLE}/dashboard.html"
      
      - name: Guardar cambios en el repositorio
        run: |
          # Añadir todos los archivos generados
          git add "core/results/webs/"
          
          # Verificar si hay cambios para hacer commit
          if git diff --staged --quiet; then
            echo "No hay cambios para hacer commit"
          else
            git commit -m "[Ka0S] Actualizando archivos de estructura web"
            git push origin ${{ env.KAOS_REF }}
          fi
  handle-success:
    runs-on:
      group: ka0s
    needs: [job-core, job-data, job-design]
    if: ${{ success() }}
    steps:
      - id: repo
        name: Checkout code
        if: ${{ always() }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      - id: handle-success-execution
        name: handle-success-execution
        env:
          GH_TOKEN: ${{ secrets.KAOS_REPO_TOKEN }}
        run: |
          # Si todo ha ido correcto añadimos el contenido del fichero
          # RNNUMBER=$(echo "${{ github.ref }}" | grep -o '[0-9]*')
          RNNUMBER=220
          #gh issue comment $RNNUMBER --body "El proceso ha finalizado correctamente ${{ env.KAOS_CODE }}. El resultado está en el fichero core/results/event_data${{ env.KAOS_CODE }}.log"
  
  handle_failure:
    runs-on:
      group: ka0s
    needs: [job-core, job-data, job-design, handle-success]
    if: ${{ failure() }}
    steps:
      - id: repo
        name: Checkout code
        if: ${{ always() }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      - id: handle-failure-execution
        name: handle-failure-execution
        env:
          GH_TOKEN: ${{ secrets.KAOS_REPO_TOKEN }}
        run: |
          echo "Error detected in process"
          # RNNUMBER=$(echo "${{ github.ref }}" | grep -o '[0-9]*')
          RNNUMBER=220
          #gh issue comment $RNNUMBER --body "El proceso no ha finalizado correctamente ${{ env.KAOS_CODE }}. El resultado está en el fichero core/results/event_data${{ env.KAOS_CODE }}.log"
          
      - id: revert-changes
        name: Revert changes made by workflow
        run: |
          echo "Reverting changes made by the workflow..."
          
          # Extract title to know which folders to remove
          STRUCTURE_FILE="${{ env.KAOS_JSON_WEB }}"
          if [ -f "$STRUCTURE_FILE" ]; then
            TITLE=$(cat $STRUCTURE_FILE | grep -o '"title": *"[^"]*"' | cut -d'"' -f4)
            if [ -z "$TITLE" ]; then
              TITLE="dashboard"
              echo "Title not found in JSON file, using default: $TITLE"
            else
              echo "Reverting changes for: $TITLE"
            fi
            
            # Remove created directories and files
            if [ -d "${{ env.KAOS_WEB_STRUCTURE }}$TITLE" ]; then
              echo "Removing web structure directory: ${{ env.KAOS_WEB_STRUCTURE }}$TITLE"
              rm -rf "${{ env.KAOS_WEB_STRUCTURE }}$TITLE"
            fi
            
            if [ -d "${{ env.KAOS_JSON_RESUME }}$TITLE" ]; then
              echo "Removing resume directory: ${{ env.KAOS_JSON_RESUME }}$TITLE"
              rm -rf "${{ env.KAOS_JSON_RESUME }}$TITLE"
            fi
            
            # Commit the removal
            git config --global user.name "${{ secrets.KAOS_BOT_NAME }}"
            git config --global user.email "${{ secrets.KAOS_BOT_EMAIL }}"
            git pull
            git add "${{ env.KAOS_WEB_STRUCTURE }}"
            git add "${{ env.KAOS_JSON_RESUME }}"
            
            # Check if there are changes to commit
            if git diff --staged --quiet; then
              echo "No changes to revert"
            else
              git commit -m "[Ka0S] Reverting changes due to workflow failure"
              git push origin ${{ env.KAOS_REF }}
              echo "Changes successfully reverted"
            fi
          else
            echo "Structure file not found, cannot determine what to revert"
          fi
  end-workflow:
    runs-on:
      group: ka0s
    needs: [job-core, job-data, job-design, handle-success, handle_failure]
    if: ${{ always() && !contains(github.event.head_commit.message, '[Ka0S] ') }}
    env:
        GH_TOKEN: ${{ secrets.KAOS_ACTIONS_TOKEN }}
    steps:
      - id: repo
        name: Checkout code
        if: ${{ always() }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.KAOS_REPO_TOKEN }}
      - id: end-process
        name: Finaliza el workflow
        run: |
          echo "End process"
          # RNNUMBER=$(echo "${{ github.ref }}" | grep -o '[0-9]*')
          RNNUMBER=220
          #gh issue comment $RNNUMBER --body "Se finaliza Ka0s ${{ env.KAOS_CODE }}"
          gh workflow run inspector.yml --ref 'main' -f kaos-issue-id=$RNNUMBER -f kaos-workflow-id="${{ env.KAOS_CODE }}" -f kaos-user-start=""
      
  