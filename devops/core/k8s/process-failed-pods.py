import json
import os
import sys
import urllib.request
import urllib.parse
import ssl
import base64

# =================================================================================================
# [Ka0S] Process Failed Pods -> iTop Tickets (Reconciliation Mode)
# =================================================================================================
# Propósito: Sincronizar el estado de los pods fallidos con los tickets de iTop.
# Lógica:
#   1. Obtener Pods Fallidos Actuales (del JSON).
#   2. Obtener Tickets Abiertos en iTop (vía OQL).
#   3. CREAR tickets para nuevos fallos.
#   4. CERRAR tickets para fallos resueltos.
# =================================================================================================

def get_itop_headers(user, password):
    auth_str = f"{user}:{password}"
    b64_auth = base64.b64encode(auth_str.encode()).decode()
    return {
        'Authorization': f"Basic {b64_auth}"
        # 'Content-Type': 'application/x-www-form-urlencoded' # urllib handles this
    }

def itop_request(url, data, headers):
    ctx = ssl.create_default_context()
    ctx.check_hostname = False
    ctx.verify_mode = ssl.CERT_NONE
    
    encoded_data = urllib.parse.urlencode({'json_data': json.dumps(data)}).encode('utf-8')
    full_url = f"{url}/webservices/rest.php?version=1.3"
    print(f"[DEBUG] POST to {full_url}")
    
    req = urllib.request.Request(full_url, data=encoded_data, headers=headers, method='POST')
    
    try:
        with urllib.request.urlopen(req, context=ctx) as response:
            return json.loads(response.read().decode('utf-8'))
    except urllib.error.HTTPError as e:
        print(f"[FATAL] HTTP Error {e.code}: {e.reason}")
        if e.code == 502:
            print("[HINT] iTop server is returning Bad Gateway. Is the iTop pod running?")
        try:
            error_body = e.read().decode('utf-8')
            print(f"[FATAL] Response Body: {error_body}")
        except:
            print("[FATAL] Could not read error body")
        sys.exit(1)
    except urllib.error.URLError as e:
        print(f"[FATAL] URL Error: {e.reason}")
        sys.exit(1)
    except Exception as e:
        print(f"[FATAL] Unexpected Error: {e}")
        sys.exit(1)

def get_open_tickets(itop_url, headers):
    """
    Recupera todos los UserRequest abiertos creados por la auditoría.
    Filtra por: Class=UserRequest, Status!=closed/resolved, Origin=monitoring, Title like '[K8s Audit]%'
    """
    oql = "SELECT UserRequest WHERE origin='monitoring' AND status NOT IN ('resolved', 'closed') AND title LIKE '[K8s Audit]%'"
    
    payload = {
        "operation": "core/get",
        "class": "UserRequest",
        "key": oql,
        "output_fields": "title, ref, friendlyname"
    }
    
    response = itop_request(itop_url, payload, headers)
    
    tickets = {} # Key: "namespace/pod_name", Value: TicketID (Key)
    
    if response.get('code') == 0 and response.get('objects'):
        for key, obj in response['objects'].items():
            fields = obj.get('fields', {})
            title = fields.get('title', '')
            # Parsear título: "[K8s Audit] Pod Failed: namespace/pod_name"
            if "Pod Failed: " in title:
                pod_key = title.split("Pod Failed: ")[1].strip()
                tickets[pod_key] = key # key es el ID interno o ref
    
    return tickets

def create_ticket(pod, itop_url, itop_user, headers):
    metadata = pod.get('metadata', {})
    status = pod.get('status', {})
    namespace = metadata.get('namespace', 'unknown')
    name = metadata.get('name', 'unknown')
    phase = status.get('phase', 'Unknown')
    pod_key = f"{namespace}/{name}"

    print(f"[ACTION] Creating ticket for {pod_key}...")

    description = f"<h1>Automated Pod Failure Detected</h1>"
    description += f"<ul><li><b>Pod:</b> {name}</li><li><b>Namespace:</b> {namespace}</li><li><b>Phase:</b> {phase}</li></ul>"
    description += "<h3>Conditions</h3><ul>"
    for cond in status.get('conditions', []):
        if cond.get('status') != 'True':
            description += f"<li><b>{cond.get('type')}:</b> {cond.get('message', 'No message')}</li>"
    description += "</ul>"

    user_oql = f"SELECT Person JOIN User ON User.contactid = Person.id WHERE User.login = '{itop_user}'"
    org_oql = f"SELECT Organization JOIN Person ON Person.org_id = Organization.id JOIN User ON User.contactid = Person.id WHERE User.login = '{itop_user}'"

    payload = {
        "operation": "core/create",
        "class": "UserRequest",
        "comment": "Auto-generated by Ka0s Audit",
        "fields": {
            "org_id": org_oql,
            "caller_id": user_oql,
            "title": f"[K8s Audit] Pod Failed: {pod_key}",
            "description": description,
            "origin": "monitoring",
            "impact": 2,
            "urgency": 2
        }
    }
    
    resp = itop_request(itop_url, payload, headers)
    if resp.get('code') == 0:
        print(f"[SUCCESS] Created Ticket: {resp.get('objects', {}).keys()}")
    else:
        print(f"[ERROR] Create Failed: {resp.get('message')}")

def close_ticket(pod_key, ticket_id, itop_url, itop_user, headers):
    print(f"[ACTION] Auto-resolving ticket {ticket_id} for {pod_key} (Pod no longer failing)...")
    
    # Paso 1: Resolver
    payload_resolve = {
        "operation": "core/apply_stimulus",
        "class": "UserRequest",
        "key": ticket_id,
        "stimulus": "ev_resolve",
        "comment": "Pod recovered automatically. Resolved by Ka0s Audit.",
        "fields": {
            "solution": "The pod is no longer present in the failed pods audit list.",
             "agent_id": f"SELECT Person JOIN User ON User.contactid = Person.id WHERE User.login = '{itop_user}'"
        }
    }
    itop_request(itop_url, payload_resolve, headers)
    
    # Paso 2: Cerrar (Opcional, a veces es mejor dejarlo en resolved para revisión)
    # Vamos a cerrarlo para "full automation"
    payload_close = {
        "operation": "core/apply_stimulus",
        "class": "UserRequest",
        "key": ticket_id,
        "stimulus": "ev_close",
        "comment": "Auto-closing.",
        "fields": {
            "user_satisfaction": 1,
            "user_comment": "Auto-closed by system."
        }
    }
    resp = itop_request(itop_url, payload_close, headers)
    if resp.get('code') == 0:
        print(f"[SUCCESS] Closed Ticket {ticket_id}")
    else:
        print(f"[ERROR] Close Failed: {resp.get('message')}")

def main():
    itop_url = os.environ.get('ITOP_URL')
    itop_user = os.environ.get('ITOP_USER')
    itop_pass = os.environ.get('ITOP_PASSWORD')
    file_path = os.environ.get('FAILED_PODS_FILE', 'audit/kube/failed_pods.json')

    if not all([itop_url, itop_user, itop_pass]):
        print("[ERROR] Missing env vars.")
        sys.exit(1)

    headers = get_itop_headers(itop_user, itop_pass)

    # 1. Leer Estado Actual (K8s)
    current_failed_pods = {}
    if os.path.exists(file_path):
        try:
            with open(file_path, 'r') as f:
                pods_list = json.load(f)
                for pod in pods_list:
                    ns = pod.get('metadata', {}).get('namespace')
                    name = pod.get('metadata', {}).get('name')
                    current_failed_pods[f"{ns}/{name}"] = pod
        except Exception:
            pass # Si falla leer, asumimos vacío o error, mejor no hacer nada destructivo? 
                 # Si el archivo está corrupto, current_failed_pods vacío podría cerrar tickets erróneamente.
                 # Mejor validar JSON válido.
            print("[WARN] Could not read failed_pods.json. Aborting reconciliation to prevent false closures.")
            sys.exit(1)
    
    print(f"[INFO] Current Failed Pods: {len(current_failed_pods)}")

    # 2. Leer Estado Registrado (iTop)
    open_tickets = get_open_tickets(itop_url, headers)
    print(f"[INFO] Open Audit Tickets: {len(open_tickets)}")

    # 3. Reconciliación
    
    # A. Detectar Nuevos Fallos (Están en K8s, NO en iTop)
    for pod_key, pod_data in current_failed_pods.items():
        if pod_key not in open_tickets:
            create_ticket(pod_data, itop_url, itop_user, headers)
        else:
            print(f"[SKIP] Ticket already exists for {pod_key} ({open_tickets[pod_key]})")

    # B. Detectar Recuperaciones (Están en iTop, NO en K8s)
    for pod_key, ticket_id in open_tickets.items():
        if pod_key not in current_failed_pods:
            close_ticket(pod_key, ticket_id, itop_url, itop_user, headers)

if __name__ == "__main__":
    main()
