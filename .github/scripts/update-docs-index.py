import os
import re

DOCS_DIR = 'core/docs'
README_PATH = os.path.join(DOCS_DIR, 'README.md')
ROOT_INDEX_PATH = 'index.md'
MARKER_START = '<!-- MODULES_START -->'
MARKER_END = '<!-- MODULES_END -->'

CATEGORY_MAPPING = {
    'Arquitectura y Conceptos Core': [
        'ka0s', 'ka0s_core', 'ka0s_init', 'ka0s_lz', 'ka0s_architecture', 'ka0s_template'
    ],
    'CI/CD y Automatizaci√≥n': [
        'ka0s_ci_cd_k8s', 'ka0s_ssh_connect', 'ka0s_kubectl_tunnel', 'ka0s_version', 'ka0s_execution', 'ka0s_release'
    ],
    'Observabilidad y Reportes': [
        'ka0s_dashboard', 'ka0s_daily_report', 'ka0s_inspector', 'ka0s_summary', 'ka0s_itop'
    ],
    'Seguridad y Compliance': [
        'ka0s_security', 'ka0s_html', 'ka0s_json', 'ka0s_md', 'ka0s_yaml'
    ],
    'Operaciones y Mantenimiento': [
        'ka0s_cluster_update', 'kaos_cluster_restart', 'ka0s_docker', 'ka0s_mongo', 'ka0s_delete_ns'
    ]
}

def find_main_doc(folder_path, folder_name):
    # Priority list for main files
    priorities = [
        f"{folder_name}.md",
        "README.md",
        "index.md",
        "kaos-klaus.md", # Exception for release
        "docker.md"      # Exception for docker
    ]
    
    # Check specific priorities first
    for p in priorities:
        if os.path.exists(os.path.join(folder_path, p)):
            return p
            
    # Fallback: first markdown file that isn't legacy or partial
    files = [f for f in os.listdir(folder_path) if f.endswith('.md')]
    if not files:
        return None
        
    # Heuristic: try to find the shortest name or one that resembles the folder
    # Sort by length to prefer shorter names (e.g. ka0s.md vs ka0s_metodologia.md)
    files.sort(key=len)
    return files[0]

def get_title(file_path):
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip().startswith('# '):
                    return line.strip().replace('# ', '').strip()
    except Exception:
        pass
    return None

def get_category(folder_name):
    for category, items in CATEGORY_MAPPING.items():
        if folder_name in items:
            return category
    return 'Otros / Sin Categor√≠a'

def generate_modules_data():
    modules = []
    
    try:
        entries = sorted(os.listdir(DOCS_DIR))
    except FileNotFoundError:
        print(f"Error: Directory {DOCS_DIR} not found.")
        return []

    for entry in entries:
        folder_path = os.path.join(DOCS_DIR, entry)
        
        if not os.path.isdir(folder_path) or entry.startswith('.'):
            continue
            
        main_file = find_main_doc(folder_path, entry)
        if main_file:
            full_path = os.path.join(folder_path, main_file)
            title = get_title(full_path)
            display_name = title if title else entry.replace('ka0s_', '').replace('_', ' ').title()
            
            modules.append({
                'folder': entry,
                'name': display_name,
                'rel_path_core': f"./{entry}/{main_file}",
                'rel_path_root': f"core/docs/{entry}/{main_file}",
                'category': get_category(entry)
            })
            
    return modules

def update_core_readme(modules):
    with open(README_PATH, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Simple list for core/docs/README.md
    list_items = [f"- [{m['name']}]({m['rel_path_core']})" for m in modules]
    
    new_section = f"{MARKER_START}\n"
    new_section += "<!-- This section is automatically generated by .github/scripts/update-docs-index.py -->\n\n"
    new_section += "\n".join(list_items)
    new_section += f"\n\n{MARKER_END}"
    
    pattern = re.compile(f"{re.escape(MARKER_START)}.*?{re.escape(MARKER_END)}", re.DOTALL)
    
    if pattern.search(content):
        new_content = pattern.sub(new_section, content)
        with open(README_PATH, 'w', encoding='utf-8') as f:
            f.write(new_content)
        print(f"Updated {README_PATH}")
    else:
        print(f"Markers not found in {README_PATH}")

def update_root_index(modules):
    # Group by category
    categorized = {}
    for m in modules:
        cat = m['category']
        if cat not in categorized:
            categorized[cat] = []
        categorized[cat].append(m)
        
    # Define category order
    order = [
        'Arquitectura y Conceptos Core',
        'CI/CD y Automatizaci√≥n',
        'Observabilidad y Reportes',
        'Seguridad y Compliance',
        'Operaciones y Mantenimiento',
        'Otros / Sin Categor√≠a'
    ]
    
    content = "# √çndice de Documentaci√≥n Ka0s\n\n"
    content += "Bienvenido al centro de documentaci√≥n del proyecto Ka0s. A continuaci√≥n encontrar√°s el acceso directo a los m√≥dulos de documentaci√≥n organizados por tem√°tica.\n\n"
    content += "<!-- This file is automatically generated by .github/scripts/update-docs-index.py -->\n\n"
    
    for cat in order:
        if cat in categorized and categorized[cat]:
            # Add emojis based on category name (simple logic)
            emoji = "üìÇ"
            if "Arquitectura" in cat: emoji = "üèóÔ∏è"
            elif "CI/CD" in cat: emoji = "üöÄ"
            elif "Observabilidad" in cat: emoji = "üìä"
            elif "Seguridad" in cat: emoji = "üõ°Ô∏è"
            elif "Operaciones" in cat: emoji = "‚öôÔ∏è"
            
            content += f"## {emoji} {cat}\n"
            for m in categorized[cat]:
                content += f"*   [{m['name']}]({m['rel_path_root']})\n"
            content += "\n"
            
    content += "---\n"
    content += "*Para ver todos los archivos, navega a [core/docs/](core/docs/).*\n"
    
    with open(ROOT_INDEX_PATH, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"Updated {ROOT_INDEX_PATH}")

def main():
    modules = generate_modules_data()
    if modules:
        update_core_readme(modules)
        update_root_index(modules)
        print("Done.")
    else:
        print("No modules found.")

if __name__ == "__main__":
    main()
